<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Drec api documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">Drec api documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  newCertificate</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/pods/certificate-log/certificate-log.service.ts</code>
        </p>



            <p class="comment">
                <h3>Extends</h3>
            </p>
            <p class="comment">
                        <code>Certificate</code>
            </p>

        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#perDeviceCertificateLog" 
>
                                            perDeviceCertificateLog
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="perDeviceCertificateLog"></a>
                                        <span class="name "><b>perDeviceCertificateLog</b>
                                            <a href="#perDeviceCertificateLog">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>perDeviceCertificateLog:         <code><a href="../entitys/CheckCertificateIssueDateLogForDeviceEntity.html" target="_self" >CheckCertificateIssueDateLogForDeviceEntity</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../entitys/CheckCertificateIssueDateLogForDeviceEntity.html" target="_self" >CheckCertificateIssueDateLogForDeviceEntity</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Injectable,
  NotFoundException,
  NotAcceptableException,
  Logger,
  ConflictException,
  HttpException,
  HttpStatus,
} from &#x27;@nestjs/common&#x27;;
import { CheckCertificateIssueDateLogForDeviceEntity } from &#x27;../device/check_certificate_issue_date_log_for_device.entity&#x27;
import { getManager, FindOneOptions, Repository, In, IsNull, Not, Brackets, SelectQueryBuilder, FindConditions, FindManyOptions, Between, LessThanOrEqual, EntityManager } from &#x27;typeorm&#x27;;
import { FilterDTO } from &#x27;./dto/filter.dto&#x27;;
import { InjectEntityManager, InjectRepository } from &#x27;@nestjs/typeorm&#x27;;
import cleanDeep from &#x27;clean-deep&#x27;;
import { Device } from &#x27;../device/device.entity&#x27;;
import { Certificate } from &#x27;@energyweb/issuer-api&#x27;;
import { DeviceService } from &#x27;../device/device.service&#x27;;
import { DateTime } from &#x27;luxon&#x27;;
import { CertificateNewWithPerDeviceLog, CertificateWithPerdevicelog, CertificatelogResponse } from &#x27;./dto&#x27;
import { DeviceGroupService } from &#x27;../device-group/device-group.service&#x27;;
import { DeviceGroupDTO } from &#x27;../device-group/dto&#x27;
import { grouplog } from &#x27;./grouplog&#x27;;
import { issuercertificatelog } from &#x27;./issuercertificate&#x27;;
import { OffChainCertificateService, IGetAllCertificatesOptions, ICertificateReadModel } from &#x27;@energyweb/origin-247-certificate&#x27;;
import { ICertificateMetadata } from &#x27;../../utils/types&#x27;;
import { getLocalTimeZoneFromDevice } from &#x27;../../utils/localTimeDetailsForDevice&#x27;;
import { CertificateReadModelEntity } from &#x27;@energyweb/origin-247-certificate/dist/js/src/offchain-certificate/repositories/CertificateReadModel/CertificateReadModel.entity&#x27;;
import { DeviceGroup } from &#x27;../device-group/device-group.entity&#x27;;
import { Cron, CronExpression } from &#x27;@nestjs/schedule&#x27;;
import { time } from &#x27;console&#x27;;
import { deviceFilterDTO } from &#x27;./dto/deviceFilter.dto&#x27;;
import { countryCodesList } from &#x27;../../models/country-code&#x27;;
import { CountryCodeNameDTO } from &#x27;../countrycode/dto/country-code.dto&#x27;;
import { OrganizationService } from &#x27;../organization/organization.service&#x27;
import { ILoggedInUser } from &#x27;../../models&#x27;;


export interface newCertificate extends Certificate {
  perDeviceCertificateLog: CheckCertificateIssueDateLogForDeviceEntity
}
@Injectable()
export class CertificateLogService {
  private readonly logger &#x3D; new Logger(CertificateLogService.name);

  constructor(
    @InjectRepository(CheckCertificateIssueDateLogForDeviceEntity) private readonly repository: Repository&lt;CheckCertificateIssueDateLogForDeviceEntity&gt;,

    @InjectRepository(Certificate) private readonly certificaterrepository: Repository&lt;Certificate&gt;,

    @InjectRepository(CertificateReadModelEntity) private readonly cretificatereadmoduleRepository,

    @InjectRepository(DeviceGroup) private readonly deviceGroupRepository,
    @InjectEntityManager() private readonly manager: EntityManager,

    private deviceService: DeviceService,
    private devicegroupService: DeviceGroupService,
    private organizationService: OrganizationService,
    private readonly offChainCertificateService: OffChainCertificateService&lt;ICertificateMetadata&gt;,

  ) { }

  public async find(): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity[]&gt; {
    // const query &#x3D; this.getFilteredQuery(filterDto);
    return this.repository.find();
  }


  public async findByGroupId(groupId: string): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity[]&gt; {
    // const query &#x3D; this.getFilteredQuery(filterDto);
    return this.repository.find({
      where: {
        groupId
      },
    });
  }

  //   private getFilteredQuery(filter: FilterDTO): FindManyOptions&lt;CheckCertificateIssueDateLogForDeviceEntity&gt; {
  //     const where: FindConditions&lt;CheckCertificateIssueDateLogForDeviceEntity&gt; &#x3D; cleanDeep({

  //         certificate_issuance_startdate:
  //         filter.start_date &amp;&amp;
  //         filter.end_date &amp;&amp;
  //         Between(filter.start_date, filter.end_date),

  //     });
  //     const query: FindManyOptions&lt;CheckCertificateIssueDateLogForDeviceEntity&gt; &#x3D; {
  //       where

  //     };
  //     return query;
  //   }

  //   private getFilteredQuery(filterDto: UserFilterDTO): SelectQueryBuilder&lt;User&gt; {
  //     const { organizationName, status } &#x3D; filterDto;
  //     const query &#x3D; this.repository
  //       .createQueryBuilder(&#x27;user&#x27;)
  //       .leftJoinAndSelect(&#x27;user.organization&#x27;, &#x27;organization&#x27;);
  //     if (organizationName) {
  //       const baseQuery &#x3D; &#x27;organization.name ILIKE :organizationName&#x27;;
  //       query.andWhere(baseQuery, { organizationName: &#x60;%${organizationName}%&#x60; });
  //     }
  //     if (status) {
  //       query.andWhere(&#x60;user.status &#x3D; &#x27;${status}&#x27;&#x60;);
  //     }
  //     return query;
  //   }

  async Findcertificatelog(filterDto: FilterDTO): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity[]&gt; {
    const totalNumbers: any &#x3D; getManager().createQueryBuilder()
      .select(&quot;d.externalId&quot;, &quot;externalId&quot;)
      .addSelect(&quot;(COUNT(dl.id))&quot;, &quot;total&quot;)
      .from(CheckCertificateIssueDateLogForDeviceEntity, &quot;dl&quot;)
      .leftJoin(Device, &quot;d&quot;, &quot;dl.externalId &#x3D; d.externalId&quot;)
      .where(&#x27;d.organizationId &#x3D; :orgid&#x27;, { orgid: 3 })
      .andWhere(&quot;dl.readvalue_watthour&gt;0&quot;)
      .groupBy(&quot;d.externalId&quot;);
    //console.log(totalExamNumbers.getQuery())
    const devicelog &#x3D; await totalNumbers.getRawMany();
    //console.log(devicelog)

    return devicelog;

  }

  async getCertificateFromOldOrNewUfinction(groupid: string): Promise&lt;any[]&gt; {
    console.log(typeof groupid);
    console.log(groupid);
    const certifiedreservation &#x3D; await this.certificaterrepository.find(
      {
        where: {
          deviceId: groupid,
        },
       // skip: offset,
       // take: limit,
      })
     console.log(&quot;certifiedreservation&quot;,certifiedreservation)
    let request: IGetAllCertificatesOptions &#x3D; {
      //@ts-ignore
      deviceId: parseInt(groupid)
    }
    console.log(request)
    const certifiedreservation1: ICertificateReadModel&lt;ICertificateMetadata&gt;[] &#x3D; await this.cretificatereadmoduleRepository.find({
      where: {
        deviceId: groupid,
      },
     // skip: offset,
     // take: limit,
    });
    console.log(&quot;certifiedreservation1&quot;,certifiedreservation1)
    if (certifiedreservation.length &gt; 0) {
      return this.getfindreservationcertified(certifiedreservation, groupid);
    } else if (certifiedreservation1.length &gt; 0) {
      return this.getCertificatesUsingGroupIDVersionUpdateOrigin247(certifiedreservation1,groupid);
    }
  }

  async getfindreservationcertified(certifiedreservation: Certificate[], groupid: string): Promise&lt;CertificateWithPerdevicelog[]&gt; {

    const res &#x3D; await Promise.all(
      certifiedreservation.map(async (certifiedlist: CertificateWithPerdevicelog) &#x3D;&gt; {
        certifiedlist.certificateStartDate &#x3D; new Date(certifiedlist.generationStartTime * 1000).toISOString();
        certifiedlist.certificateEndDate &#x3D; new Date(certifiedlist.generationEndTime * 1000).toISOString();
        certifiedlist.perDeviceCertificateLog &#x3D; [];

        try {
          JSON.parse(certifiedlist.metadata);
        }
        catch (e) {
          console.error(e, &quot;certificate doesnt contains valid metadta&quot;, certifiedlist);
          return;
        }
        const obj &#x3D; JSON.parse(certifiedlist.metadata);
        //console.log(&quot;getdate&quot;, certifiedlist.generationStartTime, certifiedlist.generationEndTime)
        /* Please see note below regarding generationStartTime
        node_modules\@energyweb\origin-247-certificate\dist\js\src\certificate.service.js
            async issue(params) {
            const command &#x3D; {
                ...params,
                fromTime: Math.round(params.fromTime.getTime() / 1000),
                toTime: Math.round(params.toTime.getTime() / 1000)
            };
            const job &#x3D; await this.blockchainActionsQueue.add({
                payload: command,
                type: types_1.BlockchainActionType.Issuance
            }, jobOptions);
            const result &#x3D; await this.waitForJobResult(job);
            return this.mapCertificate(result);
            }
         */
        const devicereadstartdate &#x3D; new Date((certifiedlist.generationStartTime - 1) * 1000);//as rounding when certificate is issued by EWFs package reference kept above and removing millseconds 
        const devicereadenddate &#x3D; new Date((certifiedlist.generationEndTime + 1) * 1000);//going back 1 second in start and going forward 1 second in end

        await Promise.all(
          obj.deviceIds.map(async (deviceid: number) &#x3D;&gt; {
            const device &#x3D; await this.deviceService.findOne(deviceid);
            const devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(groupid), device.externalId, devicereadstartdate, devicereadenddate);
            console.log(devicelog)
            devicelog.forEach(async (singleDeviceLogEle) &#x3D;&gt; {
              singleDeviceLogEle.externalId &#x3D; device.developerExternalId
              singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
              certifiedlist.perDeviceCertificateLog.push(singleDeviceLogEle);

            });

          })
        );

        return certifiedlist;
      }),
    );
    console.log(res)
    return res;
  }

  async getCertificatesUsingGroupIDVersionUpdateOrigin247( certifiedreservation,groupid: string): Promise&lt;CertificateNewWithPerDeviceLog[]&gt; {
    // let request: IGetAllCertificatesOptions &#x3D; {
    //   deviceId: groupid
    // }
    // const certifiedreservation: ICertificateReadModel&lt;ICertificateMetadata&gt;[] &#x3D; await this.offChainCertificateService.getAll(request);
    let certificatesInReservationWithLog: Array&lt;CertificateNewWithPerDeviceLog&gt; &#x3D; [];
    certifiedreservation.forEach(ele &#x3D;&gt; certificatesInReservationWithLog.push({ ...ele, perDeviceCertificateLog: [], certificateStartDate: &#x27;&#x27;, certificateEndDate: &#x27;&#x27; }));

    await Promise.all(
      certifiedreservation.map(async (certifiedlist: ICertificateReadModel&lt;ICertificateMetadata&gt;, index: number) &#x3D;&gt; {
        certificatesInReservationWithLog[index].certificateStartDate &#x3D; new Date(certifiedlist.generationStartTime * 1000).toISOString();
        certificatesInReservationWithLog[index].certificateEndDate &#x3D; new Date(certifiedlist.generationEndTime * 1000).toISOString();
        certificatesInReservationWithLog[index].perDeviceCertificateLog &#x3D; [];
        try {
          if (typeof certifiedlist.metadata &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
            let data &#x3D; JSON.parse(certifiedlist.metadata);
          }
        }
        catch (e) {
          console.error(e, &quot;certificate doesnt contains valid metadata&quot;, certifiedlist);
          return;
        }
        let obj;
        if (typeof certifiedlist.metadata &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
          obj &#x3D; JSON.parse(certifiedlist.metadata);
        }
        else {
          obj &#x3D; certifiedlist.metadata;
        }
        let certificateTransactionUID &#x3D; obj.certificateTransactionUID;
        //console.log(&quot;getdate&quot;, certifiedlist.generationStartTime, certifiedlist.generationEndTime)
        /* Below note can be ignored for newer certificates as we added certificateTransactionUID which will overcome this issue as well
        Please see note below regarding generationStartTime
        node_modules\@energyweb\origin-247-certificate\dist\js\src\certificate.service.js
            async issue(params) {
            const command &#x3D; {
                ...params,
                fromTime: Math.round(params.fromTime.getTime() / 1000),
                toTime: Math.DeviceGroupound(params.toTime.getTime() / 1000)
            };
            const job &#x3D; await this.blockchainActionsQueue.add({
                payload: command,
                type: types_1.BlockchainActionType.Issuance
            }, jobOptions);
            const result &#x3D; await this.waitForJobResult(job);
            return this.mapCertificate(result);
            }
         */
        const devicereadstartdate &#x3D; new Date((certifiedlist.generationStartTime - 1) * 1000);//as rounding when certificate is issued by EWFs package reference kept above and removing millseconds 
        const devicereadenddate &#x3D; new Date((certifiedlist.generationEndTime + 1) * 1000);//going back 1 second in start and going forward 1 second in end

        await Promise.all(
          obj.deviceIds.map(async (deviceid: number) &#x3D;&gt; {
            const device &#x3D; await this.deviceService.findOne(deviceid);
            const devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(groupid), device.externalId, devicereadstartdate, devicereadenddate, certificateTransactionUID);
            devicelog.forEach(singleDeviceLogEle &#x3D;&gt; {
              singleDeviceLogEle.externalId &#x3D; device.developerExternalId
              singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);

              certificatesInReservationWithLog[index].perDeviceCertificateLog.push(singleDeviceLogEle);
            });

            return devicelog;
          })
        );
        //console.log(&quot;perDeviceCertificateLog&quot;);
        return certificatesInReservationWithLog[index];
      }),
    );
    return certificatesInReservationWithLog;
  }

  public async getCheckCertificateIssueDateLogForDevice(groupId: number, deviceid: string,
    startDate: Date,
    endDate: Date, certificateTransactionUID?: string): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity[]&gt; {
    try {
      let devicelog;

      if (certificateTransactionUID) {
        devicelog &#x3D; await this.getDevicelogFromTransactionUID(groupId, deviceid, certificateTransactionUID);
        return devicelog;
      }
      else {
        const query &#x3D; this.getdevicelogFilteredQueryWithGroupID(groupId, deviceid,
          startDate,
          endDate);
        devicelog &#x3D; await query.getRawMany();
      }
      const reservedevices &#x3D; await devicelog.map((s: any) &#x3D;&gt; {
        const item: any &#x3D; {
          id: s.issuelog_id,
          certificate_issuance_startdate: s.issuelog_certificate_issuance_startdate,
          certificate_issuance_enddate: s.issuelog_certificate_issuance_enddate,
          readvalue_watthour: s.issuelog_readvalue_watthour,
          status: s.issuelog_status,
         // deviceid: s.issuelog_externalId,
          groupId: s.issuelog_groupId
        };
        console.log(item);
        return item;
      });
      console.log(reservedevices)
      return reservedevices;
    } catch (error) {
      console.log(error)
      this.logger.error(&#x60;Failed to retrieve device&#x60;, error.stack);
    }
  }
  private getdevicelogFilteredQueryWithGroupID(groupId: number, deviceid: string,
    startDate: Date,
    endDate: Date): SelectQueryBuilder&lt;CheckCertificateIssueDateLogForDeviceEntity&gt; {
    const query &#x3D; this.repository
      .createQueryBuilder(&quot;issuelog&quot;).
      where(&quot;issuelog.externalId &#x3D; :deviceid&quot;, { deviceid: deviceid })
      .andWhere(
        new Brackets((db) &#x3D;&gt; {
          db.where(
            new Brackets((db1) &#x3D;&gt; {
              db1.where(&quot;issuelog.certificate_issuance_startdate BETWEEN :DeviceReadingStartDate1  AND :DeviceReadingEndDate1&quot;, { DeviceReadingStartDate1: startDate, DeviceReadingEndDate1: endDate })
                .orWhere(&quot;issuelog.certificate_issuance_startdate &#x3D; :DeviceReadingStartDate&quot;, { DeviceReadingStartDate: startDate })
            })
          )
            .andWhere(
              new Brackets((db2) &#x3D;&gt; {
                db2.where(&quot;issuelog.certificate_issuance_enddate  BETWEEN :DeviceReadingStartDate2  AND :DeviceReadingEndDate2&quot;, { DeviceReadingStartDate2: startDate, DeviceReadingEndDate2: endDate })
                  .orWhere(&quot;issuelog.certificate_issuance_enddate &#x3D; :DeviceReadingEndDate &quot;, { DeviceReadingEndDate: endDate })
              })
            )
        }),
      )
      .andWhere(&quot;issuelog.groupId &#x3D; :groupId&quot;, { groupId: groupId })
    return query;
  }

  private getDevicelogFromTransactionUID(groupId: number, deviceId: string,
    certificateTransactionUID: string
  ): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity[]&gt; {
    return this.repository.find(
      {
        where: {
          groupId: groupId,
          externalId: deviceId,
          certificateTransactionUID: certificateTransactionUID
        }
      })

  }


  async getCertificaterForRedemptionRepot(groupid: string): Promise&lt;Certificate[]&gt; {
    const certifiedreservation &#x3D; await this.certificaterrepository.find(
      {
        where: {
          deviceId: groupid,
          claims: Not(IsNull())
        }
      })
    return certifiedreservation;
  }
  async getCertificateRedemptionReport(buyerId: number): Promise&lt;any[]&gt; {
    const devicegroups &#x3D; await this.devicegroupService.getBuyerDeviceGroups(buyerId);
    //console.log(devicegroups);
    const myredme &#x3D; [];
    const res &#x3D; await Promise.all(
      devicegroups.map(async (devicegroup: DeviceGroupDTO) &#x3D;&gt; {
        console.log(devicegroup.id.toString());
        const cert &#x3D; await this.getCertificaterForRedemptionRepot(devicegroup.id.toString());
        //console.log(cert)
        const res1 &#x3D; await Promise.all(
          cert.map(async (claimcertificate: Certificate) &#x3D;&gt; {
            //console.log(&quot;datas&quot;)
            //console.log(claimcertificate);
            const res2 &#x3D; await Promise.all(
              claimcertificate.claims.map(async (claims: any) &#x3D;&gt; {
                // console.log(claims.claimData);

                myredme.push({
                  compliance: &#x27;I-REC&#x27;,
                  certificateId: claimcertificate.id,
                  fuelCode: devicegroup?.fuelCode.toString().split(&#x27;,&#x27;),
                  country: devicegroup?.countryCode.toString().split(&#x27;,&#x27;),
                  capacityRange: devicegroup?.capacityRange,
                  // installations: devicegroup?.installationConfigurations ? devicegroup?.installationConfigurations.join().replace(&#x27;,&#x27;, &#x27;, &#x27;) : &#x27;&#x27;,
                  offTakers: devicegroup?.offTakers.join().replace(&#x27;,&#x27;, &#x27; ,&#x27;).toString().split(&#x27;,&#x27;),
                  // sectors: devicegroup?.sectors ? devicegroup?.sectors.join().replace(&#x27;,&#x27;, &#x27;, &#x27;) : &#x27;&#x27;,
                  commissioningDateRange: devicegroup?.commissioningDateRange
                    .join().replace(&#x27;,&#x27;, &#x27;, &#x27;),
                  //standardCompliance: devicegroup?.standardCompliance,
                  redemptionDate: claims.claimData.periodStartDate.substring(claims.claimData.periodStartDate.indexOf(&quot;:&quot;) + 1),
                  certifiedEnergy: claims.value / 10 ** 6,
                  beneficiary: claims.claimData.beneficiary.substring(claims.claimData.beneficiary.indexOf(&quot;:&quot;) + 1),
                  beneficiary_address: claims.claimData.location.substring(claims.claimData.location.indexOf(&quot;:&quot;) + 1),
                  claimCoiuntryCode: claims.claimData.countryCode.substring(claims.claimData.countryCode.indexOf(&quot;:&quot;) + 1),
                  purpose: claims.claimData.purpose.substring(claims.claimData.purpose.indexOf(&quot;:&quot;) + 1)
                });
              }),
            );
          }),
        );

      }),
    );
    //console.log(res);
    return myredme;
  }


  // async getmissingtoken() {
  //   const grouploglist &#x3D; grouplog;
  //   // console.log(grouploglist);
  //   const issuerlistlist &#x3D; issuercertificatelog;
  //   //  console.log(issuerlistlist);
  //   const missingtoken &#x3D; [];
  //   issuerlistlist.map((issuertoken: any) &#x3D;&gt; {
  //     console.log(&quot;issuertoken&quot;);
  //     // console.log(issuertoken.owners);
  //     //let issuertokenvalue&#x3D; JSON.parse(issuertoken.owners);
  //     var issuertokenvalue &#x3D; JSON.parse(issuertoken.owners);
  //     //  console.log(issuertokenvalue);
  //     var value &#x3D; issuertokenvalue[&quot;0x320Bbee0D0CE23302eDDb2707B2DdED3e49E4437&quot;];
  //      console.log(value);
  //     // let firstKey &#x3D; Object.keys(issuertokenvalue)[0];
  //     // let firstKeyValue &#x3D; issuertokenvalue[firstKey];
  //     // issuertokenvalue[key]
  //     //   console.log(firstObj);
  //     //   let firstKey &#x3D; Object.keys(firstObj);
  //     //   console.log(firstKey);
  //     //  // let issuertokenvalue &#x3D; issuertoken.owners[firstKey];
  //     //   // let issuertokenvalue &#x3D; Object.values(issuertoken.owners);
  //     // console.log(firstKeyValue);
  //     var foundEle &#x3D;  grouploglist.find(ele &#x3D;&gt; ele.readvalue_watthour !&#x3D; value);
  //     if(foundEle){
  //       missingtoken.push({
  //         token: foundEle.readvalue_watthour,
  //         foundEle
  //       });
  //     }


  //   });
  //   console.log(missingtoken);
  //   return missingtoken
  // }



  // async getsCertificateReadModule(userOrgId: string, generationStartTime, generationEndTime, pageNumber: number) {
  //   if (pageNumber &lt;&#x3D; 0) {
  //     throw new HttpException(&#x27;Invalid page number&#x27;, HttpStatus.BAD_REQUEST);
  //   }

  //   generationStartTime &#x3D; new Date(generationStartTime).getTime() / 1000;
  //   generationEndTime &#x3D; new Date(generationEndTime).getTime() / 1000;

  //   const queryBuilder &#x3D; this.cretificatereadmoduleRepository.createQueryBuilder(&#x27;certificate_read_module&#x27;)
  //     .innerJoin(&#x27;DeviceGroup&#x27;, &#x27;dg&#x27;, &#x27;certificate_read_module.deviceId &#x3D; CAST(dg.Id AS character varying)&#x27;)
  //     .andWhere(&#x27;dg.organizationId &#x3D; :userOrgId&#x27;, { userOrgId });

  //   if (generationStartTime &amp;&amp; generationEndTime) {
  //     queryBuilder.andWhere(&#x27;certificate_read_module.generationStartTime &lt;&#x3D; :generationEndTime&#x27;, {
  //       generationEndTime: generationEndTime,
  //     })
  //       .andWhere(&#x27;certificate_read_module.generationEndTime &gt;&#x3D; :generationStartTime&#x27;, {
  //         generationStartTime: generationStartTime,
  //       });
  //   }

  //   const limit &#x3D; 10;
  //   const offset &#x3D; (pageNumber - 1) * limit;

  //   const [results, totalCount] &#x3D; await queryBuilder
  //     .skip(offset)
  //     .take(limit)
  //     .getManyAndCount();

  //   const totalPages &#x3D; Math.ceil(totalCount / limit);

  //   if (pageNumber &gt; totalPages) {
  //     throw new HttpException(&#x27;Page number out of range&#x27;, HttpStatus.NOT_FOUND);
  //   }

  //   for (const result of results) {
  //     const deviceGroup &#x3D; await this.deviceGroupRepository.findOne({ id: result.deviceId });
  //     result.deviceGroup &#x3D; deviceGroup;

  //     // Parse metadata as JSON
  //     result.metadata &#x3D; JSON.parse(result.metadata);
  //   }

  //   return {
  //     &quot;results&quot;: results,
  //     &quot;pageNumber&quot;: pageNumber,
  //     &quot;totalPages&quot;: totalPages,
  //   };
  // }

  //  @Cron(CronExpression.EVERY_30_SECONDS)
  async getsCertificateReadModule(userOrgId: string, pageNumber: number, deviceFilter: deviceFilterDTO, generationStartTime?: string, generationEndTime?: string, targetVolumeCertificateGenerationRequestedInMegaWattHour?: number) {
    const pageSize &#x3D; 3;

    if (pageNumber &lt;&#x3D; 0) {
      throw new HttpException(&#x27;Invalid page number&#x27;, HttpStatus.BAD_REQUEST);
    }

    const skip &#x3D; (pageNumber - 1) * pageSize;

    let queryBuilder &#x3D; this.cretificatereadmoduleRepository.createQueryBuilder(&#x27;crm&#x27;)
      .innerJoin(DeviceGroup, &#x27;dg&#x27;, &#x27;crm.deviceId &#x3D; dg.id::text&#x27;)
      .andWhere(&#x27;dg.organizationId &#x3D; :userOrgId&#x27;, { userOrgId })
      .skip(skip)
      .take(pageSize);
    if (generationStartTime &amp;&amp; generationEndTime) {
      const startTimestamp &#x3D; new Date(generationStartTime).getTime() / 1000;
      const endTimestamp &#x3D; new Date(generationEndTime).getTime() / 1000;

      queryBuilder &#x3D; queryBuilder.andWhere(&#x27;crm.generationStartTime &lt;&#x3D; :endTimestamp&#x27;, { endTimestamp })
        .andWhere(&#x27;crm.generationEndTime &gt;&#x3D; :startTimestamp&#x27;, { startTimestamp });
    } else if (generationStartTime) {
      const startTimestamp &#x3D; new Date(generationStartTime).getTime() / 1000;

      queryBuilder &#x3D; queryBuilder.andWhere(&#x27;crm.generationStartTime &lt;&#x3D; :startTimestamp&#x27;, { startTimestamp });
    } else if (generationEndTime) {
      const endTimestamp &#x3D; new Date(generationEndTime).getTime() / 1000;

      queryBuilder &#x3D; queryBuilder.andWhere(&#x27;crm.generationEndTime &gt;&#x3D; :endTimestamp&#x27;, { endTimestamp });
    }

    if (targetVolumeCertificateGenerationRequestedInMegaWattHour !&#x3D;&#x3D; undefined) {
      queryBuilder &#x3D; queryBuilder.andWhere(&#x27;dg.targetVolumeCertificateGenerationRequestedInMegaWattHour &lt;&#x3D; :targetVolume&#x27;, { targetVolume: targetVolumeCertificateGenerationRequestedInMegaWattHour });
    }

    console.log(&quot;BEFORE QUERY:::::::::::::::::::::&quot; + new Date());
    const results &#x3D; await queryBuilder.getRawMany();
    const count &#x3D; await queryBuilder.getCount();
    console.log(&quot;AFTER QUERY:::::::::::::::::::::&quot; + new Date());

    const totalPages &#x3D; Math.ceil(count / pageSize);

    if (pageNumber &gt; totalPages) {
      throw new HttpException(&#x27;Page number out of range&#x27;, HttpStatus.NOT_FOUND);
    }

    const formattedResults &#x3D; results.map((result) &#x3D;&gt; {
      const parsedMetadata &#x3D; JSON.parse(result.crm_metadata);
      return {
        ...result,
        crm_metadata: parsedMetadata,
      };
    });

    return {
      result: formattedResults,
      pageNumber: pageNumber,
      totalPages: totalPages,
      totalCount: count,
    };
  }
  // add function for check the last end certified log in active reservation time 
  async getLastCertifiedDevicelogBYgroupId(
    groupId: number, deviceId: string
  ): Promise&lt;CheckCertificateIssueDateLogForDeviceEntity&gt; {
    return this.repository.findOne(
      {
        where: {
          groupId: groupId,
          deviceid: deviceId,

        },
        order: {
          certificate_issuance_enddate: &#x27;DESC&#x27;
        }
      })
  }

  //add function to get the certified log which device of developer added in reservation for developer

  async getCertifiedlogofDevices(user: ILoggedInUser, filterDto: FilterDTO, pageNumber) {

    const getnewreservationinfo &#x3D; await this.devicegroupService.getReservationInforDeveloperBsise(user.organizationId, user.role, filterDto, pageNumber)
    console.log(&quot;getnewreservationinfo&quot;, getnewreservationinfo.deviceGroups.length);
    console.log(&quot;getnewreservationinfo&quot;, getnewreservationinfo);
    const getoldreservationinfo &#x3D; await this.devicegroupService.getoldReservationInforDeveloperBsise(user.organizationId, user.role, filterDto, pageNumber)
    console.log(&quot;getoldreservationinfo&quot;, getoldreservationinfo.deviceGroups.length);
    let oldcertificates;
    if (getoldreservationinfo.deviceGroups.length &gt; 0) {
      //  oldcertificates&#x3D; await this.getDeveloperfindreservationcertified(getoldreservationinfo, user.role);
      return this.getDeveloperfindreservationcertified(getoldreservationinfo, user.role);
    }
    let newcertificates;
    if (getnewreservationinfo.deviceGroups.length &gt; 0) {
      // newcertificates &#x3D; await this.getDeveloperCertificatesUsingGroupIDVersionUpdateOrigin247(getnewreservationinfo, user.role);
      console.log(&quot;580&quot;);
      return this.getDeveloperCertificatesUsingGroupIDVersionUpdateOrigin247(getnewreservationinfo, user.role);
    }
    //  const final&#x3D; [...oldcertificates.certificatelog, ...newcertificates.certificatelog]
    return {
      certificatelog: [],
      currentpage: 0,
      totalPages: 0,
      totalCount: 0
    }
  }



  async getDeveloperfindreservationcertified(certifiedreservation, role): Promise&lt;CertificatelogResponse&gt; {

    let finalcertificatesInReservationWithLog: Array&lt;any&gt; &#x3D; [];
    await Promise.all(
      certifiedreservation.deviceGroups.map(async (group: any, index: number) &#x3D;&gt; {

        console.log(typeof group.internalCertificateId)
        console.log(&quot;getreservationinfo&quot;, group.internalCertificateId);
        let newq &#x3D; await this.certificaterrepository
          .createQueryBuilder(&#x27;issuar&#x27;)
          .where(&#x60;issuar.id IN (${JSON.stringify(group.internalCertificateId).replace(/[\[\]]/g, &#x27;&#x27;)})&#x60;)

        const groupedDatasql &#x3D; await newq.getQuery();
        console.log(groupedDatasql)
        const result &#x3D; await newq.getMany();
        // console.log(result)
        const res &#x3D; await Promise.all(
          result.map(async (certifiedlist: CertificateWithPerdevicelog) &#x3D;&gt; {

            certifiedlist.certificateStartDate &#x3D; new Date(certifiedlist.generationStartTime * 1000).toISOString();
            certifiedlist.certificateEndDate &#x3D; new Date(certifiedlist.generationEndTime * 1000).toISOString();
            certifiedlist.perDeviceCertificateLog &#x3D; [];

            try {
              JSON.parse(certifiedlist.metadata);
            }
            catch (e) {
              console.error(e, &quot;certificate doesnt contains valid metadta&quot;, certifiedlist);
              return;
            }
            const obj &#x3D; JSON.parse(certifiedlist.metadata);

            const devicereadstartdate &#x3D; new Date((certifiedlist.generationStartTime - 1) * 1000);//as rounding when certificate is issued by EWFs package reference kept above and removing millseconds 
            const devicereadenddate &#x3D; new Date((certifiedlist.generationEndTime + 1) * 1000);//going back 1 second in start and going forward 1 second in end
            //console.log(&quot;changegetdate&quot;, devicereadstartdate, devicereadenddate)
            await Promise.all(
              obj.deviceIds.map(async (deviceid: number) &#x3D;&gt; {

                const device &#x3D; await this.deviceService.findOne(deviceid);

                let devicelog;
                if (role &#x3D;&#x3D;&#x3D; &#x27;OrganizationAdmin&#x27;) {
                  if (group.developerdeviceIds.find(ele &#x3D;&gt; ele &#x3D;&#x3D;&#x3D; deviceid)) {
                    console.log(&quot;oldlog exist in developer&quot;);
                    const devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate);
                    devicelog.forEach(singleDeviceLogEle &#x3D;&gt; {
                      singleDeviceLogEle.externalId &#x3D; device.developerExternalId
                      singleDeviceLogEle[&#x27;deviceId&#x27;] &#x3D; device.id
                      // if (device.timezone !&#x3D; null) {
                      //   singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; device.timezone
                      // }
                      singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
                      certifiedlist.perDeviceCertificateLog.push(singleDeviceLogEle);
                    });
                  }
                  else {
                    console.log(&quot;oldlog exist in developer&quot;);
                    let totalvalue;
                    const devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate);
                    if (devicelog.length &gt; 0) {
                      const totalReadValue &#x3D; devicelog.reduce(
                        (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue.readvalue_watthour,
                        0,
                      );
                      devicelog[0].readvalue_watthour &#x3D; totalReadValue;
                      devicelog[0].externalId &#x3D; &#x27;Other Devices&#x27;;
                      devicelog[0][&#x27;deviceId&#x27;] &#x3D; 0
                      devicelog[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
                      certifiedlist.perDeviceCertificateLog.push(devicelog[0])

                    }

                  }
                }
                if (role &#x3D;&#x3D;&#x3D; &#x27;Buyer&#x27;) {

                  devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate);
                  devicelog.forEach(singleDeviceLogEle &#x3D;&gt; {
                    singleDeviceLogEle.externalId &#x3D; device.developerExternalId
                    singleDeviceLogEle[&#x27;deviceId&#x27;] &#x3D; device.id
                    singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
                    certifiedlist.perDeviceCertificateLog.push(singleDeviceLogEle);
                  });
                }

                //   return devicelog;
              })
            );
            finalcertificatesInReservationWithLog.push(certifiedlist)
            return certifiedlist;
          }),
        );

        return res;
      })
    )
    const response &#x3D; {
      certificatelog: finalcertificatesInReservationWithLog,
      currentpage: certifiedreservation.pageNumber,
      totalPages: certifiedreservation.totalPages,
      totalCount: certifiedreservation.totalCount
    }
    return response;
    //return finalcertificatesInReservationWithLog
  }

  async getDeveloperCertificatesUsingGroupIDVersionUpdateOrigin247(getreservationinfo, role): Promise&lt;CertificatelogResponse&gt; {
    let finalcertificatesInReservationWithLog: Array&lt;any&gt; &#x3D; [];
    await Promise.all(
      getreservationinfo.deviceGroups.map(async (group: any, index: number) &#x3D;&gt; {
        console.log(typeof group.internalCertificateId)

        let newq &#x3D; await this.cretificatereadmoduleRepository
          .createQueryBuilder(&#x27;crm&#x27;)
          .where(&#x60;crm.internalCertificateId IN (${JSON.stringify(group.internalCertificateId).replace(/[\[\]]/g, &#x27;&#x27;)})&#x60;)
        const groupedDatasql &#x3D; await newq.getQuery();
        console.log(groupedDatasql)
        const result &#x3D; await newq.getMany();
        // console.log(result)
        let certificatesInReservationWithLog: Array&lt;CertificateNewWithPerDeviceLog&gt; &#x3D; [];
        result.forEach(ele &#x3D;&gt; certificatesInReservationWithLog.push({ ...ele, perDeviceCertificateLog: [], certificateStartDate: &#x27;&#x27;, certificateEndDate: &#x27;&#x27; }));
        await Promise.all(
          result.map(async (certifiedlist: ICertificateReadModel&lt;ICertificateMetadata&gt;, index: number) &#x3D;&gt; {
            certificatesInReservationWithLog[index].certificateStartDate &#x3D; new Date(certifiedlist.generationStartTime * 1000).toISOString();
            certificatesInReservationWithLog[index].certificateEndDate &#x3D; new Date(certifiedlist.generationEndTime * 1000).toISOString();
            certificatesInReservationWithLog[index].perDeviceCertificateLog &#x3D; [];
            try {
              if (typeof certifiedlist.metadata &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
                let data &#x3D; JSON.parse(certifiedlist.metadata);
              }
            }
            catch (e) {
              console.error(e, &quot;certificate doesnt contains valid metadata&quot;, certifiedlist);
              return;
            }

            let obj;
            if (typeof certifiedlist.metadata &#x3D;&#x3D;&#x3D; &quot;string&quot;) {
              obj &#x3D; JSON.parse(certifiedlist.metadata);
            }
            else {
              obj &#x3D; certifiedlist.metadata;
            }
            let certificateTransactionUID &#x3D; obj.certificateTransactionUID;
            const devicereadstartdate &#x3D; new Date((certifiedlist.generationStartTime - 1) * 1000);//as rounding when certificate is issued by EWFs package reference kept above and removing millseconds 
            const devicereadenddate &#x3D; new Date((certifiedlist.generationEndTime + 1) * 1000);//going back 1 second in start and going forward 1 second in end
            await Promise.all(
              obj.deviceIds.map(async (deviceid: number) &#x3D;&gt; {
                const device &#x3D; await this.deviceService.findOne(deviceid);
                let devicelog;
                if (role &#x3D;&#x3D;&#x3D; &#x27;OrganizationAdmin&#x27;) {
                  if (group.developerdeviceIds.find(ele &#x3D;&gt; ele &#x3D;&#x3D;&#x3D; deviceid)) {

                    devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate, certificateTransactionUID);
                    devicelog.forEach(singleDeviceLogEle &#x3D;&gt; {
                      singleDeviceLogEle.externalId &#x3D; device.developerExternalId
                      singleDeviceLogEle[&#x27;deviceId&#x27;] &#x3D; device.id
                      singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);

                      certificatesInReservationWithLog[index].perDeviceCertificateLog.push(singleDeviceLogEle);
                    });
                  }
                  else {
                    devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate, certificateTransactionUID);
                    if (devicelog.length &gt; 0) {
                      const totalReadValue &#x3D; devicelog.reduce(
                        (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue.readvalue_watthour,
                        0,
                      );
                      devicelog[0].readvalue_watthour &#x3D; totalReadValue;
                      devicelog[0].externalId &#x3D; &#x27;Other Devices&#x27;
                      devicelog[0][&#x27;deviceId&#x27;] &#x3D; 0
                      devicelog[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
                      certificatesInReservationWithLog[index].perDeviceCertificateLog.push(devicelog[0])
                    }
                  }
                }
                if (role &#x3D;&#x3D;&#x3D; &#x27;Buyer&#x27;) {
                  devicelog &#x3D; await this.getCheckCertificateIssueDateLogForDevice(parseInt(group.dg_id), device.externalId, devicereadstartdate, devicereadenddate, certificateTransactionUID);
                  devicelog.forEach(singleDeviceLogEle &#x3D;&gt; {
                    singleDeviceLogEle.externalId &#x3D; device.developerExternalId
                    singleDeviceLogEle[&#x27;deviceId&#x27;] &#x3D; device.id
                    singleDeviceLogEle[&#x27;timezone&#x27;] &#x3D; getLocalTimeZoneFromDevice(device.createdAt, device);
                    certificatesInReservationWithLog[index].perDeviceCertificateLog.push(singleDeviceLogEle);
                  });
                }
                return devicelog;
              })
            );
            finalcertificatesInReservationWithLog.push(certificatesInReservationWithLog[index])
            return certificatesInReservationWithLog[index];
          }),
        );
      })
    )
    const response &#x3D; {
      certificatelog: finalcertificatesInReservationWithLog,
      currentpage: getreservationinfo.pageNumber,
      totalPages: getreservationinfo.totalPages,
      totalCount: getreservationinfo.totalCount
    }
    return response;
    //return finalcertificatesInReservationWithLog
  }


}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'newCertificate.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
